	private static final List<String> inProcess = new ArrayList<>();
	
	
	/*if (Holder.get(user == null)) { // null or expired
		if(checkInProcessAndWaitOrTake == true){
				
			try {
				// perform auth operation
				
				Holder.put(user);

			}
			finally {
				removeFromInProcessAndNotifyAll();
			}	
		}
		else {
			Holder.take(user);
		}
	}*/

	public boolean checkInProcessAndWait(String user) throws InterruptedException {

		synchronized (inProcess) {

			int index = inProcess.indexOf(user);
			if (index != -1) {
				inProcess.get(index).wait(); // wait for another thread
				return false;
			} else
				inProcess.add(user); // I will take care of it
			return true;
		}
	}

	public void addToInProcess(String user) {

		synchronized (inProcess) {
			inProcess.add(user);
		}
	}

	public void removeFromInProcessAndNotifyAll(String user) {

		synchronized (inProcess) {
			int index = inProcess.indexOf(user);
			inProcess.get(index).notifyAll();
			inProcess.remove(index);
		}
	}

\d{1,3}(,\d{3})*
^([1-9]\d{0,2}|0)([,]\d{3})*$

http://websystique.com/spring-boot/spring-boot-rest-api-example/

public class Tester {
	public static void main(String[] args) {

		LocalDateTime ofInstant = LocalDateTime.ofInstant(Instant.now(), ZoneId.of("America/New_York")); // ZoneId.of(ZoneId.SHORT_IDS.get("EST")));
		System.out.println(ofInstant);

		DateTimeFormatter pattern = DateTimeFormatter.ofPattern("'Some time' yyyy-MM-dd h-mm-ss a");

		LocalDateTime parse = LocalDateTime.parse("Some time 2017-04-16 8-25-46 AM", pattern); // AM/PM
																								// should
																								// be
																								// upper
		System.out.println(parse);

		// Duration.between(ofInstant, parse).

		System.out.println(ChronoUnit.MINUTES.between(parse, ofInstant));
		System.out.println(Duration.between(parse, ofInstant).getSeconds());

		
		System.out.println(Instant.now().toEpochMilli());
		System.out.println(ZonedDateTime.of(LocalDateTime.now(), ZoneId.of("America/New_York")).toInstant().toEpochMilli());  // time in future
		
		
	}
}


===========================================================================
	
	// with SimpleDateFormat
		// 1. if we don't specify time it will be 00:00:00
		// 2. if we don't specify date it will be Jan 01 1970
		
		String date = "1:45 PM";
		
		SimpleDateFormat simple = new SimpleDateFormat("h:mm a");
		System.out.println(simple.parse(date));
		
		
		DateTimeFormatter form = DateTimeFormatter.ofPattern("h:mm a");
		//LocalDateTime dateTime = LocalDateTime.parse(date, form);
		
		LocalTime localTime = LocalTime.parse(date, form);	
		System.out.println(localTime);
		
		String date2 = "2:24p";
		date2 = date2.replace("p", " PM").replace("a", " AM");
		localTime = LocalTime.parse(date2, form);	
		System.out.println(localTime);
		
		LocalDateTime finalDate = LocalDateTime.of(LocalDate.now(), localTime);
		System.out.println(finalDate);
		
		LocalDateTime plusDays = finalDate.plusDays(2);
		System.out.println(finalDate.compareTo(plusDays));
		
		
		
		// ==================================
		String original = "2017/02/15";
		DateTimeFormatter newOne = DateTimeFormatter.ofPattern("yyyy/MM/dd");
		LocalDate newDate = LocalDate.parse(original, newOne);
		System.out.println(newDate);
		
		SimpleDateFormat newSimple = new SimpleDateFormat("yyyy/MM/dd");
		System.out.println(newSimple.parse(original));
		
		
		//LocalDateTime time = LocalDate.parse("2017/02/15", newOne).atStartOfDay();
		
		
		// ==================================
		Calendar cal = new GregorianCalendar();
		
		date = date + " " + cal.get(Calendar.YEAR) + "/" + (cal.get(Calendar.MONTH) + 1) + "/" + cal.get(Calendar.DAY_OF_MONTH);
		System.out.println(date);
		System.out.println(new SimpleDateFormat("h:mm a yyyy/MM/dd").parse(date));







https://www.bootstrapcdn.com/bootswatch/
https://cdnjs.com/libraries/react-router

<properties>
		<jackson-2-version>2.7.0</jackson-2-version>
		<jackson-1-version>1.9.13</jackson-1-version>
	</properties>

	<dependencies>
		<!-- the core, which includes Streaming API, shared low-level abstractions 
			(but NOT data-binding) -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-core</artifactId>
			<version>${jackson-2-version}</version>
		</dependency>

		<!-- Just the annotations; use this dependency if you want to attach annotations 
			to classes without connecting them to the code. -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-annotations</artifactId>
			<version>${jackson-2-version}</version>
		</dependency>

		<!-- databinding; ObjectMapper, JsonNode and related classes are here -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
			<version>${jackson-2-version}</version>
		</dependency>
		
		
		<dependency>
            <groupId>org.codehaus.jackson</groupId>
            <artifactId>jackson-mapper-asl</artifactId>
            <version>${jackson-1-version}</version>
        </dependency>
        <dependency>
            <groupId>org.codehaus.jackson</groupId>
            <artifactId>jackson-core-asl</artifactId>
            <version>${jackson-1-version}</version>
        </dependency>


http://www.baeldung.com/jackson-serialize-enums



public static void main(String[] args) throws IOException {
		/*
		 * Collection files = FileUtils.listFiles(new File("D:\\abc"), new
		 * RegexFileFilter("^(.*?)"), DirectoryFileFilter.DIRECTORY);
		 * 
		 * System.out.println(files.toString()); for (Object file : files) {
		 * File fileObj = (File) file;
		 * System.out.println(fileObj.getCanonicalPath());
		 * System.out.println(fileObj.getName()); }
		 */

		List<String> files = printFnames("D:\\abc", new ArrayList<String>());

		for (String string : files) {
			System.out.println(string);

		}

	}


Scripts are kept in /etc/init.d, and links to them are made in the directories 
/etc/rc0.d, /etc/rc1.d, and so on
The /etc/inittabfile tells initwhat to do at each run level.

Red Hat supplies a chkconfigcommand to help you manage services. This command adds or removes startup scripts from the system, manages the run levels at 
which they operate, and lists the run levels for which a script is currently configured. See the man page for usage information for this simple and handy tool.



https://gist.github.com/miglen/5590986
http://www.davidghedini.com/pg/entry/install_tomcat_7_on_centos


https://mprabhat.me/2012/07/02/creating-a-fix-initiator-using-quickfixj/
http://kavy.iteye.com/blog/2242463
https://github.com/quickfix-j/quickfixj/blob/master/quickfixj-examples/banzai/src/main/resources/quickfix/examples/banzai/banzai.cfg


https://maven.apache.org/guides/introduction/introduction-to-repositories.html
Build a project and copy the jar - in Tomcat webapps dir/localMavenRepository (keeping the folder structure)

add this code to the dependent project pom.xml


<repositories> 	<repository>  <id>repository</id> <url>http://localhost:8080/localMavenRepository</url> </repository> </repositories>



//-------------------Retrieve All Users--------------------------------------------------------
	
	@RequestMapping(value = "/users", method = RequestMethod.GET)
	public ResponseEntity<List<User>> listAllUsers() {
		List<User> users = userService.findAllUsers();
		if(users.isEmpty()){
			return new ResponseEntity<List<User>>(HttpStatus.NO_CONTENT);//You many decide to return HttpStatus.NOT_FOUND
		}
		return new ResponseEntity<List<User>>(users, HttpStatus.OK);
	}
	
	
	http://ricostacruz.com/cheatsheets/sh.html#ifs
	
	
	
	

Управлять прокси-сервером можно напрямую через Java интерфейс или через REST API. В этой статье мы будем рассматривать только интересующий нас Java интерфейс. Для того, чтобы подключить BrowserMob в проект нужно скачать библиотеку и добавить ее в проект, либо добавить соответствующую зависимость в pom.xml, если вы используете Maven:

<dependency>
    <groupId>net.lightbody.bmp</groupId>
    <artifactId>browsermob-proxy</artifactId>
    <version>2.0-beta-8</version>
    <scope>test</scope>
</dependency>
Если у Вас уже имеется подключенная в проект библиотека Selenium, то лучше исключить использование Selenium API, встроенного в BrowserMob. Но при этом учитывайте возможные несоответствия версий Selemium и BrowserMob:

<dependency>
    <groupId>net.lightbody.bmp</groupId>
    <artifactId>browsermob-proxy</artifactId>
    <version>2.0-beta-8</version>
    <scope>test</scope>
    <exclusions>
        <exclusion>
            <groupId>org.seleniumhq.selenium</groupId>
            <artifactId>selenium-api</artifactId>
        </exclusion>
    </exclusions>
</dependency>







BrowserMob Proxy

При использовании basic аутентификации имя пользователя и пароль включаются в состав веб-запроса в стандартный HTTP заголовок «Authorization». Из этого можно заключить, что для успешного прохождения авторизации достаточно изменить HTTP заголовок перед отправкой на сервер. Сам Selenium не умеет манипулировать отправляемыми запросами, но для этих целей отлично подойдет прокси-сервер, в частности BrowserMob Proxy в силу простоты его подключения. Об интеграции и использовании BrowserMob с Selenium WebDriver можно почитать в предыдущей статье. В случае basic авторизации net.lightbody.bmp.proxy.ProxyServer предоставляет метод для ее автоматического выполнения:

server.autoBasicAuthorization("example.com", "username", "password"); 
Важно то, что первый аргумент autoBasicAuthorization это не URL, а именно доменное имя. Он не должен содержать http:// или других частей URL. Для того, чтобы использовать учетные данные для любого домена нужно оставить первый параметр пустым.

server.autoBasicAuthorization("", "username", "password"); 
Пример автоматической basic-аутентификации с BrowserMob Proxy:

import net.lightbody.bmp.proxy.ProxyServer;
 
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.openqa.selenium.By;
import org.openqa.selenium.Proxy;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.remote.CapabilityType;
import org.openqa.selenium.remote.DesiredCapabilities;
 
public class ProxyServerBasicAutorizationTest {
 
    private ProxyServer server;
    private WebDriver driver;
 
    @Before
    public void startProxy() throws Exception {
        server = new ProxyServer(4444);
        server.start();
        server.autoBasicAuthorization("", "username", "password");
        Proxy proxy = server.seleniumProxy();
 
        DesiredCapabilities capabilities = new DesiredCapabilities();
        capabilities.setCapability(CapabilityType.PROXY, proxy);
 
        driver = new FirefoxDriver(capabilities);
    }
 
    @Test
    public void testAccessProtectedSite() throws Exception {
        driver.get("https://example.com");
        driver.findElement(By.className("sign-out"));
    }
 
    @After
    public void stopProxyServer() throws Exception {
        driver.quit();
        server.stop();
    }
}
И напоследок ложка дегтя, BrowserMob Proxy работает только с basic-аутентификацией и не предоставляет методов для работы с другими протоколами (Kerberos, NTLM и др.).

	
	
	
	



