\d{1,3}(,\d{3})*

http://websystique.com/spring-boot/spring-boot-rest-api-example/

public class Tester {
	public static void main(String[] args) {

		LocalDateTime ofInstant = LocalDateTime.ofInstant(Instant.now(), ZoneId.of("America/New_York")); // ZoneId.of(ZoneId.SHORT_IDS.get("EST")));
		System.out.println(ofInstant);

		DateTimeFormatter pattern = DateTimeFormatter.ofPattern("'Some time' yyyy-MM-dd h-mm-ss a");

		LocalDateTime parse = LocalDateTime.parse("Some time 2017-04-16 8-25-46 AM", pattern); // AM/PM
																								// should
																								// be
																								// upper
		System.out.println(parse);

		// Duration.between(ofInstant, parse).

		System.out.println(ChronoUnit.MINUTES.between(parse, ofInstant));
		System.out.println(Duration.between(parse, ofInstant).getSeconds());

		
		System.out.println(Instant.now().toEpochMilli());
		System.out.println(ZonedDateTime.of(LocalDateTime.now(), ZoneId.of("America/New_York")).toInstant().toEpochMilli());  // time in future
		
		
	}
}


===========================================================================
	
	// with SimpleDateFormat
		// 1. if we don't specify time it will be 00:00:00
		// 2. if we don't specify date it will be Jan 01 1970
		
		String date = "1:45 PM";
		
		SimpleDateFormat simple = new SimpleDateFormat("h:mm a");
		System.out.println(simple.parse(date));
		
		
		DateTimeFormatter form = DateTimeFormatter.ofPattern("h:mm a");
		//LocalDateTime dateTime = LocalDateTime.parse(date, form);
		
		LocalTime localTime = LocalTime.parse(date, form);	
		System.out.println(localTime);
		
		String date2 = "2:24p";
		date2 = date2.replace("p", " PM").replace("a", " AM");
		localTime = LocalTime.parse(date2, form);	
		System.out.println(localTime);
		
		LocalDateTime finalDate = LocalDateTime.of(LocalDate.now(), localTime);
		System.out.println(finalDate);
		
		LocalDateTime plusDays = finalDate.plusDays(2);
		System.out.println(finalDate.compareTo(plusDays));
		
		
		
		// ==================================
		String original = "2017/02/15";
		DateTimeFormatter newOne = DateTimeFormatter.ofPattern("yyyy/MM/dd");
		LocalDate newDate = LocalDate.parse(original, newOne);
		System.out.println(newDate);
		
		SimpleDateFormat newSimple = new SimpleDateFormat("yyyy/MM/dd");
		System.out.println(newSimple.parse(original));
		
		
		//LocalDateTime time = LocalDate.parse("2017/02/15", newOne).atStartOfDay();
		
		
		// ==================================
		Calendar cal = new GregorianCalendar();
		
		date = date + " " + cal.get(Calendar.YEAR) + "/" + (cal.get(Calendar.MONTH) + 1) + "/" + cal.get(Calendar.DAY_OF_MONTH);
		System.out.println(date);
		System.out.println(new SimpleDateFormat("h:mm a yyyy/MM/dd").parse(date));







https://www.bootstrapcdn.com/bootswatch/
https://cdnjs.com/libraries/react-router

<properties>
		<jackson-2-version>2.7.0</jackson-2-version>
		<jackson-1-version>1.9.13</jackson-1-version>
	</properties>

	<dependencies>
		<!-- the core, which includes Streaming API, shared low-level abstractions 
			(but NOT data-binding) -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-core</artifactId>
			<version>${jackson-2-version}</version>
		</dependency>

		<!-- Just the annotations; use this dependency if you want to attach annotations 
			to classes without connecting them to the code. -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-annotations</artifactId>
			<version>${jackson-2-version}</version>
		</dependency>

		<!-- databinding; ObjectMapper, JsonNode and related classes are here -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
			<version>${jackson-2-version}</version>
		</dependency>
		
		
		<dependency>
            <groupId>org.codehaus.jackson</groupId>
            <artifactId>jackson-mapper-asl</artifactId>
            <version>${jackson-1-version}</version>
        </dependency>
        <dependency>
            <groupId>org.codehaus.jackson</groupId>
            <artifactId>jackson-core-asl</artifactId>
            <version>${jackson-1-version}</version>
        </dependency>


http://www.baeldung.com/jackson-serialize-enums



public static void main(String[] args) throws IOException {
		/*
		 * Collection files = FileUtils.listFiles(new File("D:\\abc"), new
		 * RegexFileFilter("^(.*?)"), DirectoryFileFilter.DIRECTORY);
		 * 
		 * System.out.println(files.toString()); for (Object file : files) {
		 * File fileObj = (File) file;
		 * System.out.println(fileObj.getCanonicalPath());
		 * System.out.println(fileObj.getName()); }
		 */

		List<String> files = printFnames("D:\\abc", new ArrayList<String>());

		for (String string : files) {
			System.out.println(string);

		}

	}


Scripts are kept in /etc/init.d, and links to them are made in the directories 
/etc/rc0.d, /etc/rc1.d, and so on
The /etc/inittabfile tells initwhat to do at each run level.

Red Hat supplies a chkconfigcommand to help you manage services. This command adds or removes startup scripts from the system, manages the run levels at 
which they operate, and lists the run levels for which a script is currently configured. See the man page for usage information for this simple and handy tool.



https://gist.github.com/miglen/5590986
http://www.davidghedini.com/pg/entry/install_tomcat_7_on_centos


https://mprabhat.me/2012/07/02/creating-a-fix-initiator-using-quickfixj/
http://kavy.iteye.com/blog/2242463
https://github.com/quickfix-j/quickfixj/blob/master/quickfixj-examples/banzai/src/main/resources/quickfix/examples/banzai/banzai.cfg


https://maven.apache.org/guides/introduction/introduction-to-repositories.html
Build a project and copy the jar - in Tomcat webapps dir/localMavenRepository (keeping the folder structure)

add this code to the dependent project pom.xml


<repositories> 	<repository>  <id>repository</id> <url>http://localhost:8080/localMavenRepository</url> </repository> </repositories>



//-------------------Retrieve All Users--------------------------------------------------------
	
	@RequestMapping(value = "/users", method = RequestMethod.GET)
	public ResponseEntity<List<User>> listAllUsers() {
		List<User> users = userService.findAllUsers();
		if(users.isEmpty()){
			return new ResponseEntity<List<User>>(HttpStatus.NO_CONTENT);//You many decide to return HttpStatus.NOT_FOUND
		}
		return new ResponseEntity<List<User>>(users, HttpStatus.OK);
	}
	
	
	http://ricostacruz.com/cheatsheets/sh.html#ifs
	
	
	
	
	
	
	
	
	public class Test {

	public static void main(String[] args) {
		Map<String, String> meta = new HashMap<>();
		meta.put("e1", "value1");
		meta.put("e2", "value2");
		meta.put("e3", "value3");
		
		
		Map<String, String> sorted = sortMeta(meta, getDependencies());
		System.out.println("Done");

	}

	public static void setValues(Map<String, String> meta, Object page) {
		Field[] fields = page.getClass().getDeclaredFields();

		try {
			for (Map.Entry<String, String> entry : meta.entrySet()) {

				String key = entry.getKey();
				if (entry.getValue().equals("DNF"))
					continue;

				for (Field field : fields) {
					if (field.getName().equals(key)) {

						if (Radio.class.isAssignableFrom(field.getType())) {
							Radio elem = (Radio) field.get(page);
							elem.selectByValue(entry.getValue());

						} else if (Select.class.isAssignableFrom(field.getType())) {
							Select elem = (Select) field.get(page);
							elem.selectByValue(entry.getValue());

						} else if (CheckBox.class.isAssignableFrom(field.getType())) {
							CheckBox elem = (CheckBox) field.get(page);
							elem.set(Boolean.valueOf(entry.getValue()));

						} else if (TextInput.class.isAssignableFrom(field.getType())) {
							TextInput elem = (TextInput) field.get(page);
							elem.sendKeys(entry.getValue());
						}
					}
				}
			}
		} catch (IllegalAccessException e) {
		}
	}


	public static Map<String, List<String>> getDependencies(){
		Map<String, List<String>> depend = new HashMap<>();
		depend.put("e2", Arrays.asList("e3", "e1"));
		return depend;
	}

	public static <K, V extends Comparable<? super V>> Map<K, V> sortMeta(Map<K, V> map,
			Map<String, List<String>> depend) {
		List<Map.Entry<K, V>> list = new LinkedList<>(map.entrySet());
		Collections.sort(list, new Comparator<Map.Entry<K, V>>() {
			@Override
			public int compare(Map.Entry<K, V> o1, Map.Entry<K, V> o2) {

				if (depend.get(o1.getKey()) != null && depend.get(o1.getKey()).contains(o2.getKey()))
					return -1;
				else if (depend.get(o2.getKey()) != null && depend.get(o2.getKey()).contains(o1.getKey()))
					return 1;
				else
					return 0;
			}
		});

		Collections.reverse(list);
		Map<K, V> result = new LinkedHashMap<>();
		for (Map.Entry<K, V> entry : list) {
			result.put(entry.getKey(), entry.getValue());
		}
		return result;
	}
}






Управлять прокси-сервером можно напрямую через Java интерфейс или через REST API. В этой статье мы будем рассматривать только интересующий нас Java интерфейс. Для того, чтобы подключить BrowserMob в проект нужно скачать библиотеку и добавить ее в проект, либо добавить соответствующую зависимость в pom.xml, если вы используете Maven:

<dependency>
    <groupId>net.lightbody.bmp</groupId>
    <artifactId>browsermob-proxy</artifactId>
    <version>2.0-beta-8</version>
    <scope>test</scope>
</dependency>
Если у Вас уже имеется подключенная в проект библиотека Selenium, то лучше исключить использование Selenium API, встроенного в BrowserMob. Но при этом учитывайте возможные несоответствия версий Selemium и BrowserMob:

<dependency>
    <groupId>net.lightbody.bmp</groupId>
    <artifactId>browsermob-proxy</artifactId>
    <version>2.0-beta-8</version>
    <scope>test</scope>
    <exclusions>
        <exclusion>
            <groupId>org.seleniumhq.selenium</groupId>
            <artifactId>selenium-api</artifactId>
        </exclusion>
    </exclusions>
</dependency>







BrowserMob Proxy

При использовании basic аутентификации имя пользователя и пароль включаются в состав веб-запроса в стандартный HTTP заголовок «Authorization». Из этого можно заключить, что для успешного прохождения авторизации достаточно изменить HTTP заголовок перед отправкой на сервер. Сам Selenium не умеет манипулировать отправляемыми запросами, но для этих целей отлично подойдет прокси-сервер, в частности BrowserMob Proxy в силу простоты его подключения. Об интеграции и использовании BrowserMob с Selenium WebDriver можно почитать в предыдущей статье. В случае basic авторизации net.lightbody.bmp.proxy.ProxyServer предоставляет метод для ее автоматического выполнения:

server.autoBasicAuthorization("example.com", "username", "password"); 
Важно то, что первый аргумент autoBasicAuthorization это не URL, а именно доменное имя. Он не должен содержать http:// или других частей URL. Для того, чтобы использовать учетные данные для любого домена нужно оставить первый параметр пустым.

server.autoBasicAuthorization("", "username", "password"); 
Пример автоматической basic-аутентификации с BrowserMob Proxy:

import net.lightbody.bmp.proxy.ProxyServer;
 
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.openqa.selenium.By;
import org.openqa.selenium.Proxy;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.remote.CapabilityType;
import org.openqa.selenium.remote.DesiredCapabilities;
 
public class ProxyServerBasicAutorizationTest {
 
    private ProxyServer server;
    private WebDriver driver;
 
    @Before
    public void startProxy() throws Exception {
        server = new ProxyServer(4444);
        server.start();
        server.autoBasicAuthorization("", "username", "password");
        Proxy proxy = server.seleniumProxy();
 
        DesiredCapabilities capabilities = new DesiredCapabilities();
        capabilities.setCapability(CapabilityType.PROXY, proxy);
 
        driver = new FirefoxDriver(capabilities);
    }
 
    @Test
    public void testAccessProtectedSite() throws Exception {
        driver.get("https://example.com");
        driver.findElement(By.className("sign-out"));
    }
 
    @After
    public void stopProxyServer() throws Exception {
        driver.quit();
        server.stop();
    }
}
И напоследок ложка дегтя, BrowserMob Proxy работает только с basic-аутентификацией и не предоставляет методов для работы с другими протоколами (Kerberos, NTLM и др.).

	
	
	
	
	
	
	package operation;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.InputStreamReader;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.net.URL;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.Map;
import java.util.Map.Entry;

import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import com.fasterxml.jackson.databind.ObjectMapper;

public abstract class AbstractOperation<REQ, RESP> {

	static {
		TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
			public X509Certificate[] getAcceptedIssuers() {
				return null;
			}

			@Override
			public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {
				// Not implemented
			}

			@Override
			public void checkServerTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {
				// Not implemented
			}
		} };

		try {
			SSLContext sc = SSLContext.getInstance("TLS");

			sc.init(null, trustAllCerts, new java.security.SecureRandom());

			HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
		} catch (KeyManagementException e) {
			e.printStackTrace();
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		}
	}
	
	public abstract RESP invoke(REQ request) throws Exception;
	public abstract String getUrl();
	public abstract Map<String, String> getHeaders();

	public Map<String, String> headers;
	public REQ request;
	public RESP response;

	public void setRequest(REQ request) {
		this.request = request;
	}

	public RESP sendGet() throws Exception {

		URL obj = new URL(getUrl());
		HttpsURLConnection con = (HttpsURLConnection) obj.openConnection();

		con.setRequestMethod("GET");
		for (Entry<String, String> header : getHeaders().entrySet()) {
			con.setRequestProperty(header.getKey(), header.getValue());
		}

		int responseCode = con.getResponseCode();

		if (responseCode == HttpsURLConnection.HTTP_OK) {
			BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));
			String inputLine;
			StringBuffer response = new StringBuffer();

			while ((inputLine = in.readLine()) != null) {
				response.append(inputLine);
			}
			in.close();

			ObjectMapper mapper = new ObjectMapper();
			this.response = (RESP) mapper.readValue(response.toString(), getResponseType());
			return this.response;

		}

		return null;
	}


	private RESP sendPost(REQ body) throws Exception {

		URL obj = new URL(getUrl());
		HttpsURLConnection con = (HttpsURLConnection) obj.openConnection();

		con.setRequestMethod("POST");
		con.setDoOutput(true);
		for (Entry<String, String> header : getHeaders().entrySet()) {
			con.setRequestProperty(header.getKey(), header.getValue());
		}

		DataOutputStream wr = new DataOutputStream(con.getOutputStream());
		wr.writeBytes(new ObjectMapper().writeValueAsString(body));
		wr.flush();
		wr.close();

		int responseCode = con.getResponseCode();

		if (responseCode == HttpsURLConnection.HTTP_OK || responseCode == HttpsURLConnection.HTTP_CREATED) {
			BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));
			String inputLine;
			StringBuffer response = new StringBuffer();

			while ((inputLine = in.readLine()) != null) {
				response.append(inputLine);
			}
			in.close();

			ObjectMapper mapper = new ObjectMapper();
			this.response = (RESP) mapper.readValue(response.toString(), getResponseType());
			return this.response;
		}
		return null;

	}


	public Class<?> getRequestType() {
		Type t = getClass().getGenericSuperclass();
		ParameterizedType p = (ParameterizedType) t;
		return (Class<?>) p.getActualTypeArguments()[0];
	}

	public Class<?> getResponseType() {
		Type t = getClass().getGenericSuperclass();
		ParameterizedType p = (ParameterizedType) t;
		return (Class<?>) p.getActualTypeArguments()[1];
	}

}











package operation;

import java.util.Map;

public class AuthOperation extends AbstractOperation<String, String> {

	public String name;
	
	@Override
	public String invoke(String request) throws Exception {
		return sendGet();
	}
	
	@Override
	public String getUrl() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Map<String, String> getHeaders() {
		// TODO Auto-generated method stub
		return null;
	}

	public AuthOperation(String name) {
		this.name = name;
	}

	public static void main(String[] args) throws Exception {
		AuthOperation auth = new AuthOperation("Andrei");
		auth.invoke("dfsd");
	}

}

